import asyncio
from playwright.async_api import async_playwright
import re

class AutomationEngine:
    def __init__(self, max_concurrent=5):
        self.max_concurrent = max_concurrent
        self.semaphore = asyncio.Semaphore(self.max_concurrent)
        self.is_cancelled = False

    def cancel(self):
        self.is_cancelled = True

    async def execute_template_on_router(self, ip, port, script, progress_callback=None, visible=False):
        if self.is_cancelled:
            if progress_callback:
                progress_callback(ip, "Cancelado")
            return {"ip": ip, "status": "cancelled", "message": "Operação cancelada pelo usuário"}
            
        async with self.semaphore:
            # We wrap the playwright execution inside the semaphore to limit concurrent browsers
            async with async_playwright() as p:
                browser = None
                try:
                    # Depending on the network, headless might be preferred.
                    # For routers, sometimes headless=False helps debug SSL issues.
                    browser = await p.chromium.launch(headless=not visible)
                    context = await browser.new_context(ignore_https_errors=True)
                    page = await context.new_page()
                    # Set default timeout to 15 seconds to fail faster on dead IPs than 30s default
                    page.set_default_timeout(15000)
                    
                    if progress_callback:
                        progress_callback(ip, "Iniciando conexão...")
                    
                    # The script stored in DB needs to be executed within this context.
                    # Ideally, the stored script is a python async function body generated by Codegen
                    # Here we inject variables into the script context
                    local_env = {
                        'page': page,
                        'ip': ip,
                        'port': port,
                        'asyncio': asyncio
                    }
                    
                    # Security note: In a real app we might want a safer way to parse actions
                    # For this MVP, we exec the python code generated by Playwright inspector
                    # The script should expect the 'page' variable to exist.
                    
                    # Inject variables into the script string
                    parsed_script = script.replace('{{IP}}', ip)
                    parsed_script = parsed_script.replace('{{PORT}}', port)
                    
                    if progress_callback:
                        progress_callback(ip, "Aplicando configurações...")
                        
                    # We wrap the script in an async function to execute it
                    # Ensure indentations are perfect for exec() while keeping internal indentation
                    cleaned_lines = []
                    for line in parsed_script.splitlines():
                        if line.strip(): # Ignore completely empty lines but preserve leading spaces of valid lines
                            cleaned_lines.append("    " + line)
                    
                    # Always append pass to prevent IndentationError if the script only contained comments
                    cleaned_lines.append("    pass")
                        
                    body = "\n".join(cleaned_lines)
                    wrapped_script = f"async def run_automation(page):\n{body}\n"

                    # Execute the definition into local_env
                    exec(wrapped_script, globals(), local_env)
                    
                    if self.is_cancelled:
                        raise Exception("Operação cancelada pelo usuário")
                    
                    # Run the function
                    # The function is stored in local_env and we must await its execution
                    await local_env['run_automation'](page)
                    
                    if progress_callback:
                        progress_callback(ip, "Sucesso")
                        
                    return {"ip": ip, "status": "success", "message": "Configuração aplicada"}
                
                except Exception as e:
                    if progress_callback:
                        progress_callback(ip, f"Erro: {str(e)}")
                    return {"ip": ip, "status": "error", "message": str(e)}
                finally:
                    if browser:
                        await browser.close()
                    
    def _indent_string(self, text, spaces=4):
        return '\\n'.join(' ' * spaces + line if line.strip() else line for line in text.split('\\n'))

    async def run_batch(self, devices_list, script, progress_callback=None, visible=False):
        """
        devices_list format: [{"ip": "192.168.1.1", "port": "80"}, ...]
        """
        tasks = []
        for dev in devices_list:
            if self.is_cancelled:
                break
                
            # Create a task for each device
            task = self.execute_template_on_router(
                ip=dev['ip'],
                port=dev['port'],
                script=script,
                progress_callback=progress_callback,
                visible=visible
            )
            tasks.append(task)
            
        # Run all tasks concurrently (semaphore limits active ones)
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
